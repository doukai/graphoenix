schema {
    query: QueryType
    mutation: MutationType
}

type QueryType {
    role(id: ID!): Role
    roleList(id:IDExpression, name:StringExpression): [Role]
    user(id: ID!): User
    userList(id:IDExpression, login:StringExpression, password:StringExpression, name:StringExpression, age:IntExpression, disable:Boolean, sex:SexExpression, organizationId:IntExpression, organization:OrganizationExpression): [User]
    organization(id: ID!): Organization
    organizationList(id:IDExpression, above_id:IntExpression, above:OrganizationExpression, name:StringExpression): [Organization]
    userrole(id: ID!): UserRole
    userroleList(id:IDExpression, userId:IntExpression, roleId:IntExpression): [UserRole]
}

type MutationType {
    role(id:ID, name:String): Role
    user(id:ID, login:String, password:String, name:String, age:Int, disable:Boolean, sex:Sex, organizationId:Int, organization:OrganizationInput): User
    organization(id:ID, above_id:Int, above:OrganizationInput, name:String): Organization
    userrole(id:ID, userId:Int, roleId:Int): UserRole
}

input SexExpression {
    opr:Operator = EQ
    val:Sex
    in:[Sex]
}

input RoleExpression {
    cond:Conditional = AND
    exs:[RoleExpression]
    id:IDExpression
    name:StringExpression
}

input UserExpression {
    cond:Conditional = AND
    exs:[UserExpression]
    id:IDExpression
    login:StringExpression
    password:StringExpression
    name:StringExpression
    age:IntExpression
    disable:Boolean
    sex:SexExpression
    organizationId:IntExpression
    organization:OrganizationExpression
}

input OrganizationExpression {
    cond:Conditional = AND
    exs:[OrganizationExpression]
    id:IDExpression
    above_id:IntExpression
    above:OrganizationExpression
    name:StringExpression
}

input UserRoleExpression {
    cond:Conditional = AND
    exs:[UserRoleExpression]
    id:IDExpression
    userId:IntExpression
    roleId:IntExpression
}

input RoleInput {
    id:ID
    name:String
}

input UserInput {
    id:ID
    login:String
    password:String
    name:String
    age:Int
    disable:Boolean
    sex:Sex
    organizationId:Int
    organization:OrganizationInput
}

input OrganizationInput {
    id:ID
    above_id:Int
    above:OrganizationInput
    name:String
}

input UserRoleInput {
    id:ID
    userId:Int
    roleId:Int
}

enum Operator {
    EQ
    NEQ
    LK
    NLK
    GT
    NLTE
    GTE
    NLT
    LT
    NGTE
    LTE
    NGT
    NIL
    NNIL
}

enum Conditional {
    AND
    OR
}

input IDExpression {
    opr: Operator = EQ
    val: ID
    in: [ID]
}

input StringExpression {
    opr: Operator = EQ
    val: String
    in: [String]
}

input IntExpression {
    opr: Operator = EQ
    val: Int
    in: [Int]
}

input FloatExpression {
    opr: Operator = EQ
    val: Float
    in: [Float]
}

directive @table(
    engine : String = "InnoDB"
) on OBJECT

directive @column(
    default: String
    autoIncrement: Boolean
) on FIELD_DEFINITION

directive @dataType(
    type: String
    length: Int
    decimals: Int
) on FIELD_DEFINITION

input MapWith {
    type: String
    from: String
    to: String
}

directive @map(
    from: String
    with: MapWith
    to: String
) on FIELD_DEFINITION

"""
A main title for the post
asdfas
"""
type User @table(engine:"InnoDB"){
    "test"
    id: ID! @column(autoIncrement:true)
    login  : String @column(default:"111") @dataType(length:10,decimals:2)
    password: String
    name: String
    age: Int
    disable: Boolean
    sex: [Sex]
    test2: [String]
    role: Role
}

type Role {
    id: ID! @column(autoIncrement:true)
    name: String
    users: [User]
    resources: [Resource]
    type: [RoleType]
}

type Resource {
    id: ID! @column(autoIncrement:true)
    name: String
    role: Role
}

type Organization {
    id: ID! @column(autoIncrement:true)
    above: Organization
    name: String
    users: [User]
}


enum Sex{
    MAN
    WOMAN
}
enum RoleType{
    ADMIN
    USR
}

query test{
    role(id:"user1"){
        users{
            sex
            test2
        }
    }
}
